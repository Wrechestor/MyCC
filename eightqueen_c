

int row[8];
int g_count;
int bt_count;
int tn_count;
int abs(int x) {
    // printf("aaa\n");
    if (x < 0) return -x;
    return x;
}
int testNth(int *row, int n)     //  row[0] から row[n] まで配置済み
{tn_count = tn_count + 1;
    // printf("aaa\n");
    int i;
    for(i = 0; i < n; i = i + 1) {
        if( row[i] == row[n] || abs(row[i] - row[n]) == n - i )return 0;
    }
    return 1;
}
int backtracking(int *row, int n, int NQ)     //  n:配置済みクイーン数
{bt_count = bt_count + 1;
    // puts("asdf");
    // printf("# btr !!! row:%X [%X %X %X]\n", row, &g_count, &bt_count, &tn_count);
    // printf("# btr !!! row:%X asdf %d, n: %d\n", row, bt_count, n);

    // printf("# btr !!!  %d %d %d %d %d %d, [%d %d %d], n: %d, NQ: %d\n",
    //     row[0], row[1], row[2], row[3], row[4], row[5],
    //     g_count, bt_count, tn_count, n, NQ);

    for(row[n] = 1; row[n] <= NQ; row[n] = row[n] + 1) {
        if( testNth(row, n) ) {    // 制約を満たしている場合のみ先に進む
            if( n + 1 == NQ ) {
                g_count = g_count + 1;    // 解を発見
    // printf("bt: %d, g: %d\n", bt_count, g_count);
            } else {
                backtracking(row, n+1, NQ);
            }
        }
    }
    // printf("rown %d %d %d %d %d %d, [%d %d %d], n: %d, NQ: %d\n",
    //     row[0], row[1], row[2], row[3], row[4], row[5],
    //     g_count, bt_count, tn_count, n, NQ);
    return 0;
}

int main()
{
    // g_count = 0;
    backtracking(row, 0, 8);
    printf("%d\n", g_count);
    printf("%d\n", bt_count);
    printf("%d\n", tn_count);
    return g_count;
}