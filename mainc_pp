
// 識別子の名前の最大長 

// トークンの種類 
enum TokenKind { 
TK_RESERVED, // 記号 
TK_RETURN, // return 
TK_IF, // if 
TK_ELSE, // else 
TK_WHILE, // while 
TK_FOR, // for 
TK_BREAK, // break 
TK_CONTINUE, // continue 
TK_SWITCH, // switch 
TK_CASE, // case 
TK_DEFAULT, // default 
TK_IDENT, // 識別子 
TK_NUM, // 整数トークン 
TK_INT, // int 
TK_CHAR, // char 
TK_SIZEOF, // sizeof 
TK_ENUM, // enum 
TK_STRUCT, // struct 
TK_TYPEDEF, // typedef 
TK_QUOTE, // 文字列リテラル 
TK_EOF, // 入力の終わりを表すトークン 
}; 
typedef enum TokenKind TokenKind; 

// トークン型 
struct Token { 
TokenKind kind; // トークンの型 
struct Token *next; // 次の入力トークン 
int val; // kindがTK_NUMの場合、その数値 
char *str; // トークン文字列 
int len; // トークンの長さ 
}; 
typedef struct Token Token; 


// 抽象構文木のノードの種類 
enum NodeKind { 
ND_ADD, // + 
ND_SUB, // - 
ND_MUL, // * 
ND_DIV, // / 
ND_LES, // < 
ND_LEQ, // <= 
ND_EQ, // == 
ND_NEQ, // != 
ND_ASSIGN, // = 
ND_LOGICOR, // || 
ND_LOGICAND,// && 
ND_BITOR, // | 
ND_BITXOR, // ^ 
ND_BITAND, // & 
ND_COMMA, // , 
ND_REM, // % 
ND_LSHIFT, // << 
ND_RSHIFT, // >> 
ND_LOGICNOT,// ! 
ND_BITNOT, // ~ 
ND_COND, // ? 
ND_COLON, // : 
ND_STRREF, // . 
ND_MEMBER, // . 
ND_POSTINCR,// 後置++ 
ND_POSTDECR,// 後置-- 
ND_SIZEOF, // sizeof 
ND_RETURN, // return 
ND_IF, // if 
ND_ELSE, // else 
ND_WHILE, // while 
ND_FOR, // for 
ND_FORSUP, // for内部のの2つ目以降の文 
ND_BREAK, // break 
ND_CONTINUE,// continue 
ND_SWITCH, // switch 
ND_CASE, // case 
ND_DEFAULT, // default 
ND_ENUM, // enumの定義 
ND_STRUCT, // structの定義 
ND_TYPEDEF, // typedef 
ND_BLOCK, // {} 
ND_LVAR, // ローカル変数 
ND_FUNCCALL,// 関数呼び出し 
ND_FUNCDEF, // 関数定義 
ND_ARG, // 関数の引数 
ND_ADDR, // unary & 
ND_DEREF, // unary * 
ND_VALDEF, // ローカル変数定義 
ND_GVALDEF, // グローバル変数定義 
ND_QUOTE, // 文字列リテラル 
ND_NUM, // 整数 
}; 
typedef enum NodeKind NodeKind; 

// 抽象構文木のノードの型 
struct Node { 
NodeKind kind; // ノードの型 
struct Node *lhs; // 左辺 
struct Node *rhs; // 右辺 
int val; // kindがND_NUMの場合のみ使う 
int offset; // kindがND_LVARの場合のみ使う 
char *name; // kindがND_FUMCの場合のみ,valにnameの長さを入れる 
}; 
typedef struct Node Node; 


enum type_t { INT, CHAR, PTR, ARRAY, STRUCT, MEMBER }; 

// 変数の型 
struct Type { 
enum type_t ty; 
// MEMBER:structの時の型リスト保存用 
struct Type *ptr_to; 
int array_size; // 配列のときの要素数 
struct Type *member; // structのときの型リスト 
char *name; // structのときのメンバの名前 
int len; // 名前の長さ 
}; 
typedef struct Type Type; 


// ローカル変数の型 
struct LVar { 
struct LVar *next; // 次の変数かNULL 
char *name; // 変数の名前 
int len; // 名前の長さ 
int offset; // RBPからのオフセット 
Type *type; // 変数の型 
}; 
typedef struct LVar LVar; 
// ローカル変数 
extern LVar *locals; 
extern LVar *LocalsList[100]; 
extern int localsnums[100]; 
extern int localsnum; 


// グローバル変数の型 
struct GVar { 
struct GVar *next; // 次の変数かNULL 
char *name; // 変数の名前 
int len; // 名前の長さ 
int addr; // アドレス 
Type *type; // 変数の型 
}; 
typedef struct GVar GVar; 
// グローバル変数 
extern GVar *globals; 


// 文字列リテラルの型 
struct Strs { 
struct Strs *next; // 次の変数かNULL 
char *text; // 内容 
int len; // 長さ 
int id; // 連番のID 
}; 
typedef struct Strs Strs; 
// 文字列リテラルのリスト 
extern Strs *strs; 
extern int strsnum; 


// enum定数 
struct Constant { 
struct Constant *next; 
char *name; 
int len; 
int val; 
}; 
typedef struct Constant Constant; 
// enum定数のリスト 
extern Constant *constants; 


// enum型の名前 
struct EnumName { 
struct EnumName *next; 
char *name; 
int len; 
}; 
typedef struct EnumName EnumName; 
// enum型の名前のリスト 
extern EnumName *enumnames; 


// struct型の定義 
struct StructDef { 
struct StructDef *next; 
char *name; 
int len; 
Type *type; 
}; 
typedef struct StructDef StructDef; 
// struct型の定義のリスト 
extern StructDef *structdefs; 


// 定義した型名(struct, typedef, (enum)) 
// TODO:2単語以上の型(enum A, struct Bなど) 
struct DefinedType { 
struct DefinedType *next; 
char *name; 
int len; 
Type *type; 
}; 
typedef struct DefinedType DefinedType; 
// 定義した型のリスト 
extern DefinedType *definedtypes; 


// 現在着目しているトークン 
extern Token *token; 

// 入力プログラム 
extern char *user_input; 

extern Node *code[100]; 

// 制御命令のラベル用の通し番号 
extern int branch_label; 

// 入力ファイル名 
extern char *filename; 

void error(char *fmt); 
void error_at(char *loc, char *msg); 
int consume(char *op); 
Token *consume_kind(TokenKind tkind); 
void expect(char *op); 
int expect_number(); 
int at_eof(); 
Token *new_token(TokenKind kind, Token *cur, char *str); 
void tokenize(); 
Node *new_node(NodeKind kind, Node *lhs, Node *rhs); 
Node *new_node_num(int val); 
LVar *find_lvar(Token *tok); 
GVar *find_gvar(Token *tok); 
EnumName *find_enum(Token *tok); 
StructDef *find_struct(Token *tok); 
DefinedType *find_dtype(Token *tok); 

extern int estimate_isglobal; 
Type *estimate_type(Node *node); 
int size_from_type(Type *type); 

void program(); 
Node *function_gval(); 
Node *stmt(); 
Node *expr(); 
Node *comma(); 
Node *assign(); 
Node *condition(); 
Node *logicOR(); 
Node *logicAND(); 
Node *bitOR(); 
Node *bitXOR(); 
Node *bitAND(); 
Node *equality(); 
Node *relational(); 
Node *shift(); 
Node *add(); 
Node *mul(); 
Node *unary(); 
Node *postpos(); 
Node *primary(); 

int gen_lval(Node *node); 
void gen(Node *node); 

char *filename; 

// 指定されたファイルの内容を返す 
char *read_file(char *path) { 
// ファイルを開く 
FILE *fp = fopen(path, "r"); 
if (!fp) { 
fprintf(stderr, "cannot open %s: %s", path, strerror(errno)); 
fprintf(stderr, "\n"); 
exit(1); 
} 

// ファイルの長さを調べる 
if (fseek(fp, 0, SEEK_END) == -1) { 
fprintf(stderr, "%s: fseek: %s", path, strerror(errno)); 
fprintf(stderr, "\n"); 
exit(1); 
} 
size_t size = ftell(fp); 
if (fseek(fp, 0, SEEK_SET) == -1) { 
fprintf(stderr, "%s: fseek: %s", path, strerror(errno)); 
fprintf(stderr, "\n"); 
exit(1); 
} 

// ファイル内容を読み込む 
char *buf = calloc(1, size + 2); 
fread(buf, size, 1, fp); 

// ファイルが必ず"\n\0"で終わっているようにする 
if (size == 0 || buf[size - 1] != '\n') 
buf[size++] = '\n'; 
buf[size] = '\0'; 
fclose(fp); 
return buf; 
} 


char *nodeToStr(Node *node) { 
char *namebuf = calloc(1, sizeof(char) * 100); 
if(node->name) strncpy(namebuf, node->name, node->val); 
char *ret = calloc(1, sizeof(char) * 100); 
switch (node->kind) { 
case ND_ADD: return "+"; 
case ND_SUB: return "-"; 
case ND_MUL: return "*"; 
case ND_DIV: return "/"; 
case ND_LES: return "<"; 
case ND_LEQ: return "<="; 
case ND_EQ: return "=="; 
case ND_NEQ: return "!="; 
case ND_ASSIGN: return "="; 
case ND_LOGICOR: return "||"; 
case ND_LOGICAND: return "&&"; 
case ND_BITOR: return "|"; 
case ND_BITXOR: return "^"; 
case ND_BITAND: return "&"; 
case ND_COMMA: return ","; 
case ND_REM: return "%"; 
case ND_LSHIFT: return "<<"; 
case ND_RSHIFT: return ">>"; 
case ND_LOGICNOT: return "!"; 
case ND_BITNOT: return "~"; 
case ND_POSTINCR: return "(POST)++"; 
case ND_POSTDECR: return "(POST)--"; 
case ND_COND: return "?"; 
case ND_COLON: return ":"; 
case ND_STRREF: return "."; 
case ND_MEMBER: sprintf(ret, "%s", namebuf); return ret; 
case ND_SIZEOF: return "sizeof"; 
case ND_RETURN: return "return"; 
case ND_IF: return "if"; 
case ND_ELSE: return "then | else"; 
case ND_WHILE: return "while"; 
case ND_FOR: return "for"; 
case ND_BREAK: return "break"; 
case ND_CONTINUE: return "continue"; 
case ND_SWITCH: return "switch"; 
case ND_CASE: sprintf(ret, "case %d", node->val); return ret; 
case ND_DEFAULT: return "default"; 
case ND_FORSUP: return "FORSUP"; 
case ND_BLOCK: return "BLOCK"; 
case ND_ENUM: sprintf(ret, "ENUM(%s)", namebuf); return ret; 
case ND_STRUCT: sprintf(ret, "STRUCT(%s)", namebuf); return ret; 
case ND_TYPEDEF: sprintf(ret, "TYPEDEF(%s)", namebuf); return ret; 
case ND_LVAR: sprintf(ret, "%s", namebuf); return ret; 
case ND_FUNCCALL: sprintf(ret, "CALL(%s)", namebuf); return ret; 
case ND_FUNCDEF: sprintf(ret, "FUNC(%s)", namebuf); return ret; 
case ND_ARG: return "ARG"; 
case ND_ADDR: return "ADDR"; 
case ND_DEREF: return "DEREF"; 
case ND_VALDEF: sprintf(ret, "LVAL(%s) @%d", namebuf, node->offset); return ret; 
case ND_GVALDEF: sprintf(ret, "GVAL(%s) @%d", namebuf, node->offset); return ret; 
case ND_QUOTE: 

int strid = node->val; 
Strs *nowstr = strs; 
while(nowstr) { 
if(nowstr->id == strid){ 
strncpy(namebuf, nowstr->text, nowstr->len); 
break; 
} 
nowstr = nowstr->next; 
} 
sprintf(ret, "\\\"%s\\\"", namebuf); 

return ret; 
case ND_NUM: sprintf(ret, "%d", node->val); return ret; 
} 
return ""; 
} 

int gengraph(Node *node, int nodeid) { 
int nowid = nodeid; 

printf(" node%d [label=\"%s\"", nowid, nodeToStr(node)); 
if (node->kind == ND_VALDEF || node->kind == ND_GVALDEF || 
node->kind == ND_FUNCDEF || node->kind == ND_ENUM || 
node->kind == ND_STRUCT || node->kind == ND_TYPEDEF) { 
printf(" shape = box"); 
} 
if (node->kind == ND_BLOCK) { 
printf(" shape = point"); 
} 
printf("];\n"); 
if (node->lhs) { 
nodeid = nodeid + 1; 
printf(" node%d -- node%d;\n", nowid, nodeid); 
nodeid = gengraph(node->lhs, nodeid); 
} 
if (node->rhs) { 
nodeid = nodeid + 1; 
printf(" node%d -- node%d;\n", nowid, nodeid); 
nodeid = gengraph(node->rhs, nodeid); 
} 
return nodeid; 
} 

int main(int argc, char **argv) { 
// if (argc != 2) { 
// error("引数の個数が正しくありません"); 
// return 1; 
// } 
if (argc < 2) { 
error("引数の個数が正しくありません"); 
return 1; 
} 

filename = argv[1]; 

// トークナイズしてパースする 
// 結果はcodeに保存される 
user_input = read_file(filename); 
tokenize(user_input); 
program(); 


// TODO:グラフを出力 
if (argc == 3 && strcmp(argv[2],"-g")==0) { 
// グラフを出力 
int nodeid = 1; 
printf("graph parsegraph {\n"); 
for (int i = 0; code[i]; i++) { 
nodeid = gengraph(code[i], nodeid) + 1; 
} 
printf("}\n"); 
return 0; 
} 


// アセンブリの前半部分を出力 
printf(".intel_syntax noprefix\n"); 
// printf(".text\n"); 

// 文字列リテラル 
Strs *strsptr = strs; 
for (int i = 0; i < strsnum; i++) { 
char name[MAX_IDENT_LEN]; 
strncpy(name, strsptr->text, strsptr->len); 
name[strsptr->len] = '\0'; 
printf(".LC%d:\n", strsptr->id); 
printf(" .string \"%s\"\n", name); 
printf(".text\n"); 

strsptr = strsptr->next; 
} 

if (globals) { 
printf(".bss\n"); 
} 

int last_gloval_index = -1; 
for (int i = 0; code[i]; i++) { 
if (code[i]->kind == ND_GVALDEF) last_gloval_index = i; 
} 

if (-1 == last_gloval_index) { 
// .textは最後のグローバル変数の後ろにのみ入れる 
printf(".text\n"); 
} 

// 先頭の式から順にコード生成 
for (int i = 0; code[i]; i++) { 
localsnum = localsnums[i]; 
locals = LocalsList[i]; 
gen(code[i]); 
if (i == last_gloval_index) { 
// .textは最後のグローバル変数の後ろにのみ入れる 
printf(".text\n"); 
} 
} 

return 0; 
} 
